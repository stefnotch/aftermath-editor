<!DOCTYPE html>
<head>
  <meta charset="utf-8" />
  <title>Mathml Editor</title>
  <style>
    /* so that the carets are spaced out nicely */
    msqrt::after {
      content: " ";
      width: 10px;
      min-width: 10px;
      margin: 1px;
      padding: 1px;
    }
  </style>
</head>
<body>
  <div style="width: 15em">
    This mathematical formula with a big summation and the number pi
    <math display="block" style="font-family: STIX Two" tabindex="0">
      <mrow>
        <munderover>
          <mo>∑</mo>
          <mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow>
          <mrow><mo>+</mo><mn>∞</mn></mrow>
        </munderover>
        <mfrac>
          <mn>1</mn>
          <msup><mi>n</mi><mn>2</mn></msup>
        </mfrac>
      </mrow>
      <mo>=</mo>
      <mfrac>
        <msup><mi>π</mi><mn>2</mn></msup>
        <mn>6</mn>
      </mfrac>
    </math>
    is easy to prove. This is a test
    <math display="block" style="font-family: STIX Two" tabindex="0">
      <munderover>
        <mo>cat</mo>
        <mn>27</mn>
        <mn>∞</mn>
      </munderover>
      <mo>=</mo>
      <mo>&lt;</mo>
      <mo>&gt;</mo>
      <mo>=</mo>
      <munderover>
        <mo>cat</mo>
        <mn>27</mn>
        <mn>∞</mn>
      </munderover>
    </math>

    An annotated test case. <br />
    The shiny new approach is to generate a list of valid caret positions.

    <math>
      <!--|-->
      <mfrac>
        <!--|--><msqrt>
          <mi> <!--|-->π<!--|--> </mi>
        </msqrt>
        <!--|-->
        <mn> <!--|-->6<!--|--> </mn>
      </mfrac>
      <!--|-->
      <mo>+</mo>
      <!--|-->
      <mfrac>
        <mi> <!--|-->π<!--|--> </mi>
        <mn> <!--|-->6<!--|--> </mn>
      </mfrac>
      <!--|-->
      <mo>+</mo>
      <!--|-->
      <msqrt>
        <!--|-->
        <msqrt>
          <mstyle>
            <mn> <!--|-->5<!--|--> </mn>
          </mstyle>
        </msqrt>
        <!--|-->
      </msqrt>
      <!--|-->
      <mo>+</mo>
      <!--|-->
      <mo>+</mo>
      <!--|-->
      <munderover>
        <mo> <!--|-->c<!--|--> </mo>
        <mn> <!--|-->2<!--|-->7<!--|--> </mn>
        <mn> <!--|-->∞<!--|--> </mn>
      </munderover>
      <!--|-->
    </math>

    And a quick msup torture test <br />

    <math>
      <mo>-</mo>
      <msup><mn>2</mn><mn>3</mn></msup>
      <mo>+</mo>
      <msup>
        <mn>2</mn>
        <msup><mn>4</mn><mn>8</mn></msup>
      </msup>
      <mo>*</mo>
      <msup>
        <msup><mn>2</mn><mn>3</mn></msup>
        <mn>3</mn>
      </msup>
    </math>

    <br />
    And nested mrows are also fun
    <br />

    <math>
      <mrow>
        <mo>-</mo>
        <mrow>
          <mrow><mn>2</mn></mrow>
        </mrow>
      </mrow>
    </math>

    <br />
    The simple rules
    <ol>
      <li>Always generate carets outside of the elements</li>
      <li>Don't generate carets for ...</li>
      <li>Completely ignore ... and their children</li>
      <li>
        To merge carets, we pick the starting caret locations (without loss of
        generality, you could also pick the ending caret locations). Then, when
        gerating a starting caret
        <pre>
          <code>
            generateCaret(element): boolean {
              if(element.parent is an mrow or math or msup or msub or msubsup) { 
                if(previousSibling(element) is not null) {
                  return false
                } else {
                  return generateCaret(element)
                }
              } else {
                return true
              }
            }
          </code>
        </pre>
        Basically, the idea is to check if we have a previous sibling (that
        already has a caret generated). And since we can nest mrows, we have to
        do that check recursively. TODO: Wait, it's not simply "previous
        sibling". It's a bit more involved, for example if the previous sibling
        is an (nested) mrow. Or if the previous sibling is an element that we
        entirely skip
      </li>
    </ol>
  </div>
  <script type="module" src="./script.js"></script>
</body>
